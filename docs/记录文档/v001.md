v001
耗时：上午3小时。下午1.5小时。

创建MeasurementSystem对象
def run(self)
    frame=self.capture_frame()
    cropped_frame=self.preprocessor.pre_crop(frame) # 转换到canny后，从A4纸黑边内边缘向外裁切。
    edges=self.preprocessor.preprocess(cropped_frame) # 预处理，得到canny结果
    self.border_detector.detect_border(edges) # 对canny结果查找轮廓，筛选得到黑边内轮廓的角点
    D = self.distance_calculator.calculate_D(corners) # 用角点距离和pnp计算A4纸到摄像头的距离。
    post_cropped_frame = system.border_detector.post_crop(cropped_frame, corners, inset_pixels=5) # 用找到的角点识别的结果，沿着黑边内轮廓向内裁切，避免轮廓影响形状识别
    shape, x_pix = system.shape_detector.detect_shape(post_cropped_frame) # 形状查询
    x = system.shape_detector.calculate_X(x_pix, D, system.K, adjusted_corners) # 计算实际尺寸，这里综合考虑A4纸宽、高像素映射和镜头的焦距方程。


满足误差要求

遗留问题：
calib.yaml：会随着画面裁切改变，需要动态更新

瓶颈：shape detector识别效果差，尤其是远距离

相比设计文档的改进：

使用了两次crop——先向外裁切整个A4纸，再向内裁切目标物。避免了目标物被边框干扰。

意料之外：border_detector会找到A4纸黑边的内边框，因为外边框由于环境的复杂，会无法被canny完整的识别。

经验：先写好main()或者run()，再拆分到不同的模块。测试不同的模块时，直接复制run()的内容，再加上断点和可视化即可。